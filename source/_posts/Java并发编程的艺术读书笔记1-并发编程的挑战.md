---
title:  Java并发编程的艺术读书笔记(1)-并发编程的挑战
date: 2017-05-03 23:28:45
tags: ['多线程','并发']
categories: 读书笔记
---
<!--more-->
### 1.多线程不一定就比单线程快，因为线程有创建和上下文切换的开销。
#### 1.1vmstat测试上下文切换次数,Lmbench3测时长
#### 1.2如何减少上下文切换
##### 1.2.1无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID取模分段，不同的线程处理不同段的数据。
##### 1.2.2CAS算法：JDK的Atomic包使用CAS算法来更新数据，而不需要加锁。
##### 1.2.3使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程处于等待状态。
##### 1.2.4使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
#### 1.3查看线程信息
##### 1.3.1用jstack命令dump线程信息，看看pid为31177的进程里的线程都在做什么。

```Bash
sudo -u admin /opt/ifeve/java/bin/jstack 31177 > /home/dump17
```
##### 1.3.2统计所有线程分别处于什么状态

```Bash
grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}' | sort | uniq -c
```

### 2.死锁
#### 2.1避免死锁的几个常见方法
##### 2.1.1避免一个线程同时获取多个锁。
##### 2.1.2避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
##### 2.1.3尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
##### 2.1.4对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。
### 3.资源限制（硬件，软件）